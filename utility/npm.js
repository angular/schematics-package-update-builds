"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const http = require("http");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const semver = require("semver");
const semverIntersect = require('semver-intersect');
const kPackageJsonDependencyFields = [
    'dependencies',
    'devDependencies',
    'peerDependencies',
    'optionalDependencies',
];
const npmPackageJsonCache = new Map();
function _getVersionFromNpmPackage(json, version, loose) {
    const distTags = json['dist-tags'];
    if (distTags && distTags[version]) {
        return (loose ? '~' : '') + distTags[version];
    }
    else {
        if (!semver.validRange(version)) {
            throw new schematics_1.SchematicsException(`Invalid range or version: "${version}".`);
        }
        if (semver.valid(version) && loose) {
            version = '~' + version;
        }
        const packageVersions = Object.keys(json['versions']);
        const maybeMatch = semver.maxSatisfying(packageVersions, version);
        if (!maybeMatch) {
            throw new schematics_1.SchematicsException(`Version "${version}" has no satisfying version for package ${json['name']}`);
        }
        const maybeOperator = version.match(/^[~^]/);
        if (version == '*') {
            return maybeMatch;
        }
        else if (maybeOperator) {
            return maybeOperator[0] + maybeMatch;
        }
        else {
            return (loose ? '~' : '') + maybeMatch;
        }
    }
}
/**
 * Get the NPM repository's package.json for a package. This is p
 * @param {string} packageName The package name to fetch.
 * @param {LoggerApi} logger A logger instance to log debug information.
 * @returns {Observable<JsonObject>} An observable that will put the pacakge.json content.
 * @private
 */
function _getNpmPackageJson(packageName, logger) {
    const url = `http://registry.npmjs.org/${packageName.replace(/\//g, '%2F')}`;
    logger.debug(`Getting package.json from ${JSON.stringify(packageName)}...`);
    let maybeRequest = npmPackageJsonCache.get(url);
    if (!maybeRequest) {
        const subject = new rxjs_1.ReplaySubject(1);
        const request = http.request(url, response => {
            let data = '';
            response.on('data', chunk => data += chunk);
            response.on('end', () => {
                try {
                    const json = JSON.parse(data);
                    subject.next(json);
                    subject.complete();
                }
                catch (err) {
                    subject.error(err);
                }
            });
            response.on('error', err => subject.error(err));
        });
        request.end();
        maybeRequest = subject.asObservable();
        npmPackageJsonCache.set(url, maybeRequest);
    }
    return maybeRequest;
}
/**
 * Recursively get versions of packages to update to, along with peer dependencies. Only recurse
 * peer dependencies and only update versions of packages that are in the original package.json.
 * @param {JsonObject} packageJson The original package.json to update.
 * @param {{[p: string]: string}} packages
 * @param {{[p: string]: string}} allVersions
 * @param {LoggerApi} logger
 * @param {boolean} loose
 * @returns {Observable<void>}
 * @private
 */
function _getRecursiveVersions(packageJson, packages, allVersions, logger, loose) {
    return rxjs_1.from(kPackageJsonDependencyFields).pipe(operators_1.mergeMap(field => {
        const deps = packageJson[field];
        if (deps) {
            return rxjs_1.from(Object.keys(deps)
                .map(depName => depName in deps ? [depName, deps[depName]] : null)
                .filter(x => !!x));
        }
        else {
            return rxjs_1.EMPTY;
        }
    }), operators_1.mergeMap(([depName, depVersion]) => {
        if (!packages[depName] || packages[depName] === depVersion) {
            return rxjs_1.EMPTY;
        }
        if (allVersions[depName] && semver.intersects(allVersions[depName], depVersion)) {
            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);
            return rxjs_1.EMPTY;
        }
        return _getNpmPackageJson(depName, logger).pipe(operators_1.map(json => ({ version: packages[depName], depName, depVersion, npmPackageJson: json })));
    }), operators_1.mergeMap(({ version, depName, depVersion, npmPackageJson }) => {
        const updateVersion = _getVersionFromNpmPackage(npmPackageJson, version, loose);
        const npmPackageVersions = Object.keys(npmPackageJson['versions']);
        const match = semver.maxSatisfying(npmPackageVersions, updateVersion);
        if (!match) {
            return rxjs_1.EMPTY;
        }
        if (semver.lt(semverIntersect.parseRange(updateVersion).version, semverIntersect.parseRange(depVersion).version)) {
            throw new schematics_1.SchematicsException(`Cannot downgrade package ${JSON.stringify(depName)} from version "${depVersion}" to "${updateVersion}".`);
        }
        const innerNpmPackageJson = npmPackageJson['versions'][match];
        const dependencies = {};
        const deps = innerNpmPackageJson['peerDependencies'];
        if (deps) {
            for (const depName of Object.keys(deps)) {
                dependencies[depName] = deps[depName];
            }
        }
        logger.debug(`Recording update for ${JSON.stringify(depName)} to version ${updateVersion}.`);
        if (allVersions[depName]) {
            if (!semver.intersects(allVersions[depName], updateVersion)) {
                throw new schematics_1.SchematicsException('Cannot update safely because packages have conflicting dependencies. Package '
                    + `${depName} would need to match both versions "${updateVersion}" and `
                    + `"${allVersions[depName]}, which are not compatible.`);
            }
            allVersions[depName] = semverIntersect.intersect(allVersions[depName], updateVersion);
        }
        else {
            allVersions[depName] = updateVersion;
        }
        return _getRecursiveVersions(packageJson, dependencies, allVersions, logger, loose);
    }));
}
/**
 * Use a Rule which can return an observable, but do not actually modify the Tree.
 * This rules perform an HTTP request to get the npm registry package.json, then resolve the
 * version from the options, and replace the version in the options by an actual version.
 * @param supportedPackages A list of packages to update (at the same version).
 * @param maybeVersion A version to update those packages to.
 * @param loose Whether to use loose version operators (instead of specific versions).
 * @private
 */
function updatePackageJson(supportedPackages, maybeVersion = 'latest', loose = false) {
    const version = maybeVersion ? maybeVersion : 'latest';
    // This will be updated as we read the NPM repository.
    const allVersions = {};
    return schematics_1.chain([
        (tree, context) => {
            const packageJsonContent = tree.read('/package.json');
            if (!packageJsonContent) {
                throw new schematics_1.SchematicsException('Could not find package.json.');
            }
            const packageJson = JSON.parse(packageJsonContent.toString());
            const packages = {};
            for (const name of supportedPackages) {
                packages[name] = version;
            }
            return rxjs_1.concat(_getRecursiveVersions(packageJson, packages, allVersions, context.logger, loose).pipe(operators_1.ignoreElements()), rxjs_1.of(tree));
        },
        (tree) => {
            const packageJsonContent = tree.read('/package.json');
            if (!packageJsonContent) {
                throw new schematics_1.SchematicsException('Could not find package.json.');
            }
            const packageJson = JSON.parse(packageJsonContent.toString());
            for (const field of kPackageJsonDependencyFields) {
                const deps = packageJson[field];
                if (!deps) {
                    continue;
                }
                for (const depName of Object.keys(packageJson[field])) {
                    if (allVersions[depName]) {
                        packageJson[field][depName] = allVersions[depName];
                    }
                }
            }
            tree.overwrite('/package.json', JSON.stringify(packageJson, null, 2) + '\n');
            return tree;
        },
        (_tree, context) => {
            context.addTask(new tasks_1.NodePackageInstallTask());
        },
    ]);
}
exports.updatePackageJson = updatePackageJson;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnBtLmpzIiwic291cmNlUm9vdCI6Ii4vIiwic291cmNlcyI6WyJwYWNrYWdlcy9zY2hlbWF0aWNzL3BhY2thZ2VfdXBkYXRlL3V0aWxpdHkvbnBtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBUUEsMkRBTW9DO0FBQ3BDLDREQUEwRTtBQUMxRSw2QkFBNkI7QUFDN0IsK0JBT2M7QUFDZCw4Q0FBK0Q7QUFDL0QsaUNBQWlDO0FBRWpDLE1BQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBRXBELE1BQU0sNEJBQTRCLEdBQUc7SUFDbkMsY0FBYztJQUNkLGlCQUFpQjtJQUNqQixrQkFBa0I7SUFDbEIsc0JBQXNCO0NBQ3ZCLENBQUM7QUFHRixNQUFNLG1CQUFtQixHQUFHLElBQUksR0FBRyxFQUFrQyxDQUFDO0FBRXRFLG1DQUFtQyxJQUFnQixFQUFFLE9BQWUsRUFBRSxLQUFjO0lBQ2xGLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQWUsQ0FBQztJQUNqRCxFQUFFLENBQUMsQ0FBQyxRQUFRLElBQUksUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBVyxDQUFDO0lBQzFELENBQUM7SUFBQyxJQUFJLENBQUMsQ0FBQztRQUNOLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEMsTUFBTSxJQUFJLGdDQUFtQixDQUFDLDhCQUE4QixPQUFPLElBQUksQ0FBQyxDQUFDO1FBQzNFLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDbkMsT0FBTyxHQUFHLEdBQUcs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RTdFLE1BQU0sQ0FBQyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBQ0QsQ0FBQyxLQUFXLEVBQUUsT0FBeUIsRUFBRSxFQUFFO1lBQ3pDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSw4QkFBc0IsRUFBRSxDQUFDLENBQUM7UUFDaEQsQ0FBQztLQUNGLENBQUMsQ0FBQztBQUNMLENBQUM7QUF4REQsOENBd0RDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgSnNvbk9iamVjdCwgbG9nZ2luZyB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9jb3JlJztcbmltcG9ydCB7XG4gIFJ1bGUsXG4gIFNjaGVtYXRpY0NvbnRleHQsXG4gIFNjaGVtYXRpY3NFeGNlcHRpb24sXG4gIFRyZWUsXG4gIGNoYWluLFxufSBmcm9tICdAYW5ndWxhci1kZXZraXQvc2NoZW1hdGljcyc7XG5pbXBvcnQgeyBOb2RlUGFja2FnZUluc3RhbGxUYXNrIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L3NjaGVtYXRpY3MvdGFza3MnO1xuaW1wb3J0ICogYXMgaHR0cCBmcm9tICdodHRwJztcbmltcG9ydCB7XG4gIEVNUFRZLFxuICBPYnNlcnZhYmxlLFxuICBSZXBsYXlTdWJqZWN0LFxuICBjb25jYXQsXG4gIGZyb20gYXMgb2JzZXJ2YWJsZUZyb20sXG4gIG9mIGFzIG9ic2VydmFibGVPZixcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBpZ25vcmVFbGVtZW50cywgbWFwLCBtZXJnZU1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tICdzZW12ZXInO1xuXG5jb25zdCBzZW12ZXJJbnRlcnNlY3QgPSByZXF1aXJlKCdzZW12ZXItaW50ZXJzZWN0Jyk7XG5cbmNvbnN0IGtQYWNrYWdlSnNvbkRlcGVuZGVuY3lGaWVsZHMgPSBbXG4gICdkZXBlbmRlbmNpZXMnLFxuICAnZGV2RGVwZW5kZW5jaWVzJyxcbiAgJ3BlZXJEZXBlbmRlbmNpZXMnLFxuICAnb3B0aW9uYWxEZXBlbmRlbmNpZXMnLFxuXTtcblxuXG5jb25zdCBucG1QYWNrYWdlSnNvbkNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIE9ic2VydmFibGU8SnNvbk9iamVjdD4+KCk7XG5cbmZ1bmN0aW9uIF9nZXRWZXJzaW9uRnJvbU5wbVBhY2thZ2UoanNvbjogSnNvbk9iamVjdCwgdmVyc2lvbjogc3RyaW5nLCBsb29zZTogYm9vbGVhbik6IHN0cmluZyB7XG4gIGNvbnN0IGRpc3RUYWdzID0ganNvblsnZGlzdC10YWdzJ10gYXMgSnNvbk9iamVjdDtcbiAgaWYgKGRpc3RUYWdzICYmIGRpc3RUYWdzW3ZlcnNpb25dKSB7XG4gICAgcmV0dXJuIChsb29zZSA/ICd+JyA6ICcnKSArIGRpc3RUYWdzW3ZlcnNpb25dIGFzIHN0cmluZztcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXNlbXZlci52YWxpZFJhbmdlKHZlcnNpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgU2NoZW1hdGljc0V4Y2VwdGlvbihgSW52YWxpZCByYW5nZSBvciB2ZXJzaW9uOiBcIiR7dmVyc2lvbn1cIi5gKTtcbiAgICB9XG4gICAgaWYgKHNlbXZlci52YWxpZCh2ZXJzaW9uKSAmJiBsb29zZSkge1xuICAgICAgdmVyc2lvbiA9ICd+JyArIHZlcnNpb247XG4gICAgfVxuXG4gICAgY29uc3QgcGFja2FnZVZlcnNpb25zID0gT2JqZWN0LmtleXMoanNvblsndmVyc2lvbnMnXSBhcyBKc29uT2JqZWN0KTtcbiAgICBjb25zdCBtYXliZU1hdGNoID0gc2VtdmVyLm1heFNhdGlzZnlpbmcocGFja2FnZVZlcnNpb25zLCB2ZXJzaW9uKTtcblxuICAgIGlmICghbWF5YmVNYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IFNjaGVtYXRpY3NFeGNlcHRpb24oXG4gICAgICAgIGBWZXJzaW9uIFwiJHt2ZXJzaW9ufVwiIGhhcyBubyBzYXRpc2Z5aW5nIHZlcnNpb24gZm9yIHBhY2thZ2UgJHtqc29uWyduYW1lJ119YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF5YmVPcGVyYXRvciA9IHZlcnNpb24ubWF0Y2goL15bfl5dLyk7XG4gICAgaWYgKHZlcnNpb24gPT0gJyonKSB7XG4gICAgICByZXR1cm4gbWF5YmVNYXRjaDtcbiAgICB9IGVsc2UgaWYgKG1heWJlT3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXliZU9wZXJhdG9yWzBdICsgbWF5YmVNYXRjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChsb29zZSA/ICd+JyA6ICcnKSArIG1heWJlTWF0Y2g7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBOUE0gcmVwb3NpdG9yeSdzIHBhY2thZ2UuanNvbiBmb3IgYSBwYWNrYWdlLiBUaGlzIGlzIHBcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYWNrYWdlTmFtZSBUaGUgcGFja2FnZSBuYW1lIHRvIGZldGNoLlxuICogQHBhcmFtIHtMb2dnZXJBcGl9IGxvZ2dlciBBIGxvZ2dlciBpbnN0YW5jZSB0byBsb2cgZGVidWcgaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxKc29uT2JqZWN0Pn0gQW4gb2JzZXJ2YWJsZSB0aGF0IHdpbGwgcHV0IHRoZSBwYWNha2dlLmpzb24gY29udGVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXROcG1QYWNrYWdlSnNvbihcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcbiAgbG9nZ2VyOiBsb2dnaW5nLkxvZ2dlckFwaSxcbik6IE9ic2VydmFibGU8SnNvbk9iamVjdD4ge1xuICBjb25zdCB1cmwgPSBgaHR0cDovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy8ke3BhY2thZ2VOYW1lLnJlcGxhY2UoL1xcLy9nLCAnJTJGJyl9YDtcbiAgbG9nZ2VyLmRlYnVnKGBHZXR0aW5nIHBhY2thZ2UuanNvbiBmcm9tICR7SlNPTi5zdHJpbmdpZnkocGFja2FnZU5hbWUpfS4uLmApO1xuXG4gIGxldCBtYXliZVJlcXVlc3QgPSBucG1QYWNrYWdlSnNvbkNhY2hlLmdldCh1cmwpO1xuICBpZiAoIW1heWJlUmVxdWVzdCkge1xuICAgIGNvbnN0IHN1YmplY3QgPSBuZXcgUmVwbGF5U3ViamVjdDxKc29uT2JqZWN0PigxKTtcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBodHRwLnJlcXVlc3QodXJsLCByZXNwb25zZSA9PiB7XG4gICAgICBsZXQgZGF0YSA9ICcnO1xuICAgICAgcmVzcG9uc2Uub24oJ2RhdGEnLCBjaHVuayA9PiBkYXRhICs9IGNodW5rKTtcbiAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgc3ViamVjdC5uZXh0KGpzb24gYXMgSnNvbk9iamVjdCk7XG4gICAgICAgICAgc3ViamVjdC5jb21wbGV0ZSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBzdWJqZWN0LmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmVzcG9uc2Uub24oJ2Vycm9yJywgZXJyID0+IHN1YmplY3QuZXJyb3IoZXJyKSk7XG4gICAgfSk7XG4gICAgcmVxdWVzdC5lbmQoKTtcblxuICAgIG1heWJlUmVxdWVzdCA9IHN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgbnBtUGFja2FnZUpzb25DYWNoZS5zZXQodXJsLCBtYXliZVJlcXVlc3QpO1xuICB9XG5cbiAgcmV0dXJuIG1heWJlUmVxdWVzdDtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBnZXQgdmVyc2lvbnMgb2YgcGFja2FnZXMgdG8gdXBkYXRlIHRvLCBhbG9uZyB3aXRoIHBlZXIgZGVwZW5kZW5jaWVzLiBPbmx5IHJlY3Vyc2VcbiAqIHBlZXIgZGVwZW5kZW5jaWVzIGFuZCBvbmx5IHVwZGF0ZSB2ZXJzaW9ucyBvZiBwYWNrYWdlcyB0aGF0IGFyZSBpbiB0aGUgb3JpZ2luYWwgcGFja2FnZS5qc29uLlxuICogQHBhcmFtIHtKc29uT2JqZWN0fSBwYWNrYWdlSnNvbiBUaGUgb3JpZ2luYWwgcGFja2FnZS5qc29uIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7e1twOiBzdHJpbmddOiBzdHJpbmd9fSBwYWNrYWdlc1xuICogQHBhcmFtIHt7W3A6IHN0cmluZ106IHN0cmluZ319IGFsbFZlcnNpb25zXG4gKiBAcGFyYW0ge0xvZ2dlckFwaX0gbG9nZ2VyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3NlXG4gKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTx2b2lkPn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRSZWN1cnNpdmVWZXJzaW9ucyhcbiAgcGFja2FnZUpzb246IEpzb25PYmplY3QsXG4gIHBhY2thZ2VzOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgYWxsVmVyc2lvbnM6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9LFxuICBsb2dnZXI6IGxvZ2dpbmcuTG9nZ2VyQXBpLFxuICBsb29zZTogYm9vbGVhbixcbik6IE9ic2VydmFibGU8dm9pZD4ge1xuICByZXR1cm4gb2JzZXJ2YWJsZUZyb20oa1BhY2thZ2VKc29uRGVwZW5kZW5jeUZpZWxkcykucGlwZShcbiAgICBtZXJnZU1hcChmaWVsZCA9PiB7XG4gICAgICBjb25zdCBkZXBzID0gcGFja2FnZUpzb25bZmllbGRdIGFzIEpzb25PYmplY3Q7XG4gICAgICBpZiAoZGVwcykge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZUZyb20oXG4gICAgICAgICAgT2JqZWN0LmtleXMoZGVwcylcbiAgICAgICAgICAgIC5tYXAoZGVwTmFtZSA9PiBkZXBOYW1lIGluIGRlcHMgPyBbZGVwTmFtZSwgZGVwc1tkZXBOYW1lXV0gOiBudWxsKVxuICAgICAgICAgICAgLmZpbHRlcih4ID0+ICEheCksXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgICB9XG4gICAgfSksXG4gICAgbWVyZ2VNYXAoKFtkZXBOYW1lLCBkZXBWZXJzaW9uXTogW3N0cmluZywgc3RyaW5nXSkgPT4ge1xuICAgICAgaWYgKCFwYWNrYWdlc1tkZXBOYW1lXSB8fCBwYWNrYWdlc1tkZXBOYW1lXSA9PT0gZGVwVmVyc2lvbikge1xuICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgICB9XG4gICAgICBpZiAoYWxsVmVyc2lvbnNbZGVwTmFtZV0gJiYgc2VtdmVyLmludGVyc2VjdHMoYWxsVmVyc2lvbnNbZGVwTmFtZV0sIGRlcFZlcnNpb24pKSB7XG4gICAgICAgIGFsbFZlcnNpb25zW2RlcE5hbWVdID0gc2VtdmVySW50ZXJzZWN0LmludGVyc2VjdChhbGxWZXJzaW9uc1tkZXBOYW1lXSwgZGVwVmVyc2lvbik7XG5cbiAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2dldE5wbVBhY2thZ2VKc29uKGRlcE5hbWUsIGxvZ2dlcikucGlwZShcbiAgICAgICAgbWFwKGpzb24gPT4gKHsgdmVyc2lvbjogcGFja2FnZXNbZGVwTmFtZV0sIGRlcE5hbWUsIGRlcFZlcnNpb24sIG5wbVBhY2thZ2VKc29uOiBqc29uIH0pKSxcbiAgICAgICk7XG4gICAgfSksXG4gICAgbWVyZ2VNYXAoKHt2ZXJzaW9uLCBkZXBOYW1lLCBkZXBWZXJzaW9uLCBucG1QYWNrYWdlSnNvbn0pID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZVZlcnNpb24gPSBfZ2V0VmVyc2lvbkZyb21OcG1QYWNrYWdlKG5wbVBhY2thZ2VKc29uLCB2ZXJzaW9uLCBsb29zZSk7XG4gICAgICBjb25zdCBucG1QYWNrYWdlVmVyc2lvbnMgPSBPYmplY3Qua2V5cyhucG1QYWNrYWdlSnNvblsndmVyc2lvbnMnXSBhcyBKc29uT2JqZWN0KTtcbiAgICAgIGNvbnN0IG1hdGNoID0gc2VtdmVyLm1heFNhdGlzZnlpbmcobnBtUGFja2FnZVZlcnNpb25zLCB1cGRhdGVWZXJzaW9uKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgICAgfVxuICAgICAgaWYgKHNlbXZlci5sdChcbiAgICAgICAgc2VtdmVySW50ZXJzZWN0LnBhcnNlUmFuZ2UodXBkYXRlVmVyc2lvbikudmVyc2lvbixcbiAgICAgICAgc2VtdmVySW50ZXJzZWN0LnBhcnNlUmFuZ2UoZGVwVmVyc2lvbikudmVyc2lvbilcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgU2NoZW1hdGljc0V4Y2VwdGlvbihgQ2Fubm90IGRvd25ncmFkZSBwYWNrYWdlICR7XG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZGVwTmFtZSl9IGZyb20gdmVyc2lvbiBcIiR7ZGVwVmVyc2lvbn1cIiB0byBcIiR7dXBkYXRlVmVyc2lvbn1cIi5gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbm5lck5wbVBhY2thZ2VKc29uID0gKG5wbVBhY2thZ2VKc29uWyd2ZXJzaW9ucyddIGFzIEpzb25PYmplY3QpW21hdGNoXSBhcyBKc29uT2JqZWN0O1xuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuXG4gICAgICBjb25zdCBkZXBzID0gaW5uZXJOcG1QYWNrYWdlSnNvblsncGVlckRlcGVuZGVuY2llcyddIGFzIEpzb25PYmplY3Q7XG4gICAgICBpZiAoZGVwcykge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcE5hbWUgb2YgT2JqZWN0LmtleXMoZGVwcykpIHtcbiAgICAgICAgICBkZXBlbmRlbmNpZXNbZGVwTmFtZV0gPSBkZXBzW2RlcE5hbWVdIGFzIHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsb2dnZXIuZGVidWcoYFJlY29yZGluZyB1cGRhdGUgZm9yICR7SlNPTi5zdHJpbmdpZnkoZGVwTmFtZSl9IHRvIHZlcnNpb24gJHt1cGRhdGVWZXJzaW9ufS5gKTtcblxuICAgICAgaWYgKGFsbFZlcnNpb25zW2RlcE5hbWVdKSB7XG4gICAgICAgIGlmICghc2VtdmVyLmludGVyc2VjdHMoYWxsVmVyc2lvbnNbZGVwTmFtZV0sIHVwZGF0ZVZlcnNpb24pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFNjaGVtYXRpY3NFeGNlcHRpb24oXG4gICAgICAgICAgICAnQ2Fubm90IHVwZGF0ZSBzYWZlbHkgYmVjYXVzZSBwYWNrYWdlcyBoYXZlIGNvbmZsaWN0aW5nIGRlcGVuZGVuY2llcy4gUGFja2FnZSAnXG4gICAgICAgICAgICArIGAke2RlcE5hbWV9IHdvdWxkIG5lZWQgdG8gbWF0Y2ggYm90aCB2ZXJzaW9ucyBcIiR7dXBkYXRlVmVyc2lvbn1cIiBhbmQgYFxuICAgICAgICAgICAgKyBgXCIke2FsbFZlcnNpb25zW2RlcE5hbWVdfSwgd2hpY2ggYXJlIG5vdCBjb21wYXRpYmxlLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFsbFZlcnNpb25zW2RlcE5hbWVdID0gc2VtdmVySW50ZXJzZWN0LmludGVyc2VjdChhbGxWZXJzaW9uc1tkZXBOYW1lXSwgdXBkYXRlVmVyc2lvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxWZXJzaW9uc1tkZXBOYW1lXSA9IHVwZGF0ZVZlcnNpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZ2V0UmVjdXJzaXZlVmVyc2lvbnMoXG4gICAgICAgIHBhY2thZ2VKc29uLFxuICAgICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICAgIGFsbFZlcnNpb25zLFxuICAgICAgICBsb2dnZXIsXG4gICAgICAgIGxvb3NlLFxuICAgICAgKTtcbiAgICB9KSxcbiAgKTtcbn1cblxuLyoqXG4gKiBVc2UgYSBSdWxlIHdoaWNoIGNhbiByZXR1cm4gYW4gb2JzZXJ2YWJsZSwgYnV0IGRvIG5vdCBhY3R1YWxseSBtb2RpZnkgdGhlIFRyZWUuXG4gKiBUaGlzIHJ1bGVzIHBlcmZvcm0gYW4gSFRUUCByZXF1ZXN0IHRvIGdldCB0aGUgbnBtIHJlZ2lzdHJ5IHBhY2thZ2UuanNvbiwgdGhlbiByZXNvbHZlIHRoZVxuICogdmVyc2lvbiBmcm9tIHRoZSBvcHRpb25zLCBhbmQgcmVwbGFjZSB0aGUgdmVyc2lvbiBpbiB0aGUgb3B0aW9ucyBieSBhbiBhY3R1YWwgdmVyc2lvbi5cbiAqIEBwYXJhbSBzdXBwb3J0ZWRQYWNrYWdlcyBBIGxpc3Qgb2YgcGFja2FnZXMgdG8gdXBkYXRlIChhdCB0aGUgc2FtZSB2ZXJzaW9uKS5cbiAqIEBwYXJhbSBtYXliZVZlcnNpb24gQSB2ZXJzaW9uIHRvIHVwZGF0ZSB0aG9zZSBwYWNrYWdlcyB0by5cbiAqIEBwYXJhbSBsb29zZSBXaGV0aGVyIHRvIHVzZSBsb29zZSB2ZXJzaW9uIG9wZXJhdG9ycyAoaW5zdGVhZCBvZiBzcGVjaWZpYyB2ZXJzaW9ucykuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUGFja2FnZUpzb24oXG4gIHN1cHBvcnRlZFBhY2thZ2VzOiBzdHJpbmdbXSxcbiAgbWF5YmVWZXJzaW9uID0gJ2xhdGVzdCcsXG4gIGxvb3NlID0gZmFsc2UsXG4pOiBSdWxlIHtcbiAgY29uc3QgdmVyc2lvbiA9IG1heWJlVmVyc2lvbiA/IG1heWJlVmVyc2lvbiA6ICdsYXRlc3QnO1xuICAvLyBUaGlzIHdpbGwgYmUgdXBkYXRlZCBhcyB3ZSByZWFkIHRoZSBOUE0gcmVwb3NpdG9yeS5cbiAgY29uc3QgYWxsVmVyc2lvbnM6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcblxuICByZXR1cm4gY2hhaW4oW1xuICAgICh0cmVlOiBUcmVlLCBjb250ZXh0OiBTY2hlbWF0aWNDb250ZXh0KTogT2JzZXJ2YWJsZTxUcmVlPiA9PiB7XG4gICAgICBjb25zdCBwYWNrYWdlSnNvbkNvbnRlbnQgPSB0cmVlLnJlYWQoJy9wYWNrYWdlLmpzb24nKTtcbiAgICAgIGlmICghcGFja2FnZUpzb25Db250ZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBTY2hlbWF0aWNzRXhjZXB0aW9uKCdDb3VsZCBub3QgZmluZCBwYWNrYWdlLmpzb24uJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UocGFja2FnZUpzb25Db250ZW50LnRvU3RyaW5nKCkpO1xuICAgICAgY29uc3QgcGFja2FnZXM6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc3VwcG9ydGVkUGFja2FnZXMpIHtcbiAgICAgICAgcGFja2FnZXNbbmFtZV0gPSB2ZXJzaW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uY2F0KFxuICAgICAgICBfZ2V0UmVjdXJzaXZlVmVyc2lvbnMocGFja2FnZUpzb24sIHBhY2thZ2VzLCBhbGxWZXJzaW9ucywgY29udGV4dC5sb2dnZXIsIGxvb3NlKS5waXBlKFxuICAgICAgICAgIGlnbm9yZUVsZW1lbnRzKCksXG4gICAgICAgICksXG4gICAgICAgIG9ic2VydmFibGVPZih0cmVlKSxcbiAgICAgICk7XG4gICAgfSxcbiAgICAodHJlZTogVHJlZSkgPT4ge1xuICAgICAgY29uc3QgcGFja2FnZUpzb25Db250ZW50ID0gdHJlZS5yZWFkKCcvcGFja2FnZS5qc29uJyk7XG4gICAgICBpZiAoIXBhY2thZ2VKc29uQ29udGVudCkge1xuICAgICAgICB0aHJvdyBuZXcgU2NoZW1hdGljc0V4Y2VwdGlvbignQ291bGQgbm90IGZpbmQgcGFja2FnZS5qc29uLicpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFja2FnZUpzb24gPSBKU09OLnBhcnNlKHBhY2thZ2VKc29uQ29udGVudC50b1N0cmluZygpKTtcblxuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBrUGFja2FnZUpzb25EZXBlbmRlbmN5RmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGRlcHMgPSBwYWNrYWdlSnNvbltmaWVsZF07XG4gICAgICAgIGlmICghZGVwcykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBkZXBOYW1lIG9mIE9iamVjdC5rZXlzKHBhY2thZ2VKc29uW2ZpZWxkXSkpIHtcbiAgICAgICAgICBpZiAoYWxsVmVyc2lvbnNbZGVwTmFtZV0pIHtcbiAgICAgICAgICAgIHBhY2thZ2VKc29uW2ZpZWxkXVtkZXBOYW1lXSA9IGFsbFZlcnNpb25zW2RlcE5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cmVlLm92ZXJ3cml0ZSgnL3BhY2thZ2UuanNvbicsIEpTT04uc3RyaW5naWZ5KHBhY2thZ2VKc29uLCBudWxsLCAyKSArICdcXG4nKTtcblxuICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfSxcbiAgICAoX3RyZWU6IFRyZWUsIGNvbnRleHQ6IFNjaGVtYXRpY0NvbnRleHQpID0+IHtcbiAgICAgIGNvbnRleHQuYWRkVGFzayhuZXcgTm9kZVBhY2thZ2VJbnN0YWxsVGFzaygpKTtcbiAgICB9LFxuICBdKTtcbn1cbiJdfQ==